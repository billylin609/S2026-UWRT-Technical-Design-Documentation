\section{Environment Setup}
\label{sec:environment_setup}

This section addresses key architectural decisions that drive the selection of build systems and execution strategies. Each decision is guided by project requirements and team capabilities.

\subsection{Build System Selection}
\label{subsec:build_system}

Selecting an appropriate build system is fundamental to establishing a reproducible development environment. This subsection compares two primary options: Makefile and CMakeLists.txt, examining their characteristics, strengths, and limitations.

\subsubsection{Makefile}

\textbf{Overview:} Makefile is a build automation tool that defines how source files are compiled into executable programs. A Makefile consists of rules containing a target (output file), dependencies (input files), and recipes (commands to execute). Main components include variables for compiler flags, pattern rules for compiling multiple files, and phony targets for actions like \texttt{clean} and \texttt{install}. State-of-the-art Makefiles leverage automatic variables (\texttt{\$@}, \texttt{\$<}, \texttt{\$\^}), conditional logic, and recursive make for managing complex projects.

\textbf{Advantages:} Makefile offers simplicity and minimal dependenciesâ€”it is ubiquitous on Unix-like systems with no additional installation required. Developers have direct control over the compilation process, making debugging and optimization straightforward.

\textbf{Disadvantages:} Makefiles are platform-specific and require significant adaptation for Windows. The syntax is notoriously fragile, particularly with whitespace sensitivity. Scaling to large projects with numerous dependencies becomes difficult, and the learning curve for advanced features is steep. Makefiles excel in small to medium C/C++ projects but struggle with cross-platform compatibility and modern dependency management.

\subsubsection{CMakeLists.txt}

\textbf{Overview:} CMake is a meta-build system that generates platform-specific build files (Makefiles on Linux, Visual Studio projects on Windows, Xcode on macOS). CMakeLists.txt files describe the build process in a platform-independent language. Main components include project declarations, source file lists, target definitions, find modules for locating dependencies, and installation rules. State-of-the-art CMake projects use target-based thinking (specifying libraries and executables as first-class objects), modern syntax with generator expressions, and package discovery mechanisms.

\textbf{Advantages:} CMake provides excellent cross-platform support and cleaner syntax than Makefile. It offers powerful dependency management, integration with popular package managers, and superior handling of complex multi-target projects. CMake is the de facto standard in the ROS ecosystem.

\textbf{Disadvantages:} The additional abstraction layer introduces overhead for simple projects. The initial learning curve is steeper, and the configuration phase can be slower. For small, single-file projects, Makefile may be more appropriate.

\subsubsection{Recommendation}

For UWRT projects, select CMakeLists.txt for ROS-based robotics applications and cross-platform development. Use Makefile for simple, standalone C/C++ utilities or when team expertise is limited. Python-only projects do not require either and should use \texttt{setup.py} or \texttt{pyproject.toml} for packaging.

\subsection{Build Orchestration and Execution}
\label{subsec:build_orchestration}

Build orchestration manages the workflow from source code to running application. This section describes how to implement build orchestration using Makefile, CMake, and Python, enabling developers to execute complex workflows with simple commands.

\subsubsection{Orchestration with Makefile}

Makefiles manage build orchestration by chaining targets and defining dependencies. A typical workflow defines \texttt{.PHONY} targets for distinct build stages: \texttt{build}, \texttt{test}, and \texttt{run}. The build target compiles source code, the test target runs the test suite, and the run target executes the compiled binary. Invoking \texttt{make run} automatically builds and executes the project in the correct sequence.

\begin{lstlisting}[language=make]
.PHONY: build test run clean

build:
	g++ -o bin/main src/main.cpp -I inc/

test: build
	g++ -o bin/test_main tests/test_main.cpp -I inc/
	./bin/test_main

run: build
	./bin/main

clean:
	rm -rf bin/
\end{lstlisting}

Advanced orchestration uses recursive make for modular builds or includes dependency files generated by the compiler. This approach is lightweight and familiar to most C/C++ developers.

\subsubsection{Orchestration with CMake}

CMake separates configuration from build. The typical workflow involves generating build files with \texttt{cmake} in a build directory, then invoking the underlying build system. A CMakeLists.txt file defines targets with dependencies and custom commands for orchestration:

\begin{lstlisting}[language=bash]
cmake_minimum_required(VERSION 3.10)
project(MyRobot)

add_executable(main src/main.cpp)
target_include_directories(main PRIVATE inc/)

enable_testing()
add_test(NAME MainTest COMMAND test_main)

add_custom_target(run COMMAND ./main DEPENDS main)
\end{lstlisting}

Developers configure and build with:
\begin{lstlisting}[language=bash]
cmake -B build
cmake --build build
cmake --build build --target run
\end{lstlisting}

CMake's strength lies in managing multi-target projects and handling platform-specific build details automatically. It is strongly recommended for ROS projects and applications requiring cross-platform support.

\subsubsection{Orchestration with Python}

Python projects typically use \texttt{setup.py} or \texttt{pyproject.toml} for packaging. For orchestration of complex workflows, a dedicated script using the \texttt{subprocess} module provides programmatic control:

\begin{lstlisting}[language=python]
import subprocess
import sys

def build():
    subprocess.run(['python', 'setup.py', 'build'], check=True)

def test():
    subprocess.run(['pytest', 'tests/'], check=True)

def run():
    subprocess.run(['python', '-m', 'project_name.main'], check=True)

if __name__ == '__main__':
    if len(sys.argv) < 2:
        print("Usage: python run.py [build|test|run]")
        sys.exit(1)
    
    command = sys.argv[1]
    if command == 'build':
        build()
    elif command == 'test':
        test()
    elif command == 'run':
        run()
\end{lstlisting}

For simplicity and consistency with team expectations, wrapping Python orchestration in a Makefile is recommended. This approach leverages Python's flexibility for complex logic while maintaining familiar command-line interfaces:

\begin{lstlisting}[language=make]
.PHONY: build test run clean

build:
	python run.py build

test:
	python run.py test

run:
	python run.py run

clean:
	rm -rf build/ dist/ *.egg-info
\end{lstlisting}

This pattern ensures Python projects follow the same operational workflow as C++ projects across the team.